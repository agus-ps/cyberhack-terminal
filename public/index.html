<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberHack Terminal v5.0 - Ejecución Real</title>
    <style>
        :root {
            --main-bg-color: #0a0a0a;
            --terminal-bg: #0a0e14;
            --glow-green: #00ff41;
            --glow-blue: #00b3ff;
            --glow-purple: #bd00ff;
            --text-color: #cccccc;
            --error-red: #ff0040;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background-color: var(--main-bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            line-height: 1.6;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 255, 65, 0.03) 0%, transparent 20%),
                radial-gradient(circle at 90% 60%, rgba(0, 179, 255, 0.03) 0%, transparent 20%),
                radial-gradient(circle at 50% 80%, rgba(189, 0, 255, 0.03) 0%, transparent 20%);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--glow-green);
            margin-bottom: 30px;
            position: relative;
        }

        h1 {
            font-size: 2.5rem;
            color: var(--glow-green);
            text-shadow: 0 0 10px var(--glow-green);
            letter-spacing: 2px;
            animation: flicker 5s infinite alternate;
        }

        @keyframes flicker {

            0%,
            19%,
            21%,
            23%,
            25%,
            54%,
            56%,
            100% {
                text-shadow: 0 0 10px var(--glow-green);
                opacity: 1;
            }

            20%,
            24%,
            55% {
                text-shadow: 0 0 20px var(--glow-green);
                opacity: 0.8;
            }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .tool-card {
            background-color: var(--terminal-bg);
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 5px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        }

        .tool-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .tool-card:hover::before {
            opacity: 1;
        }

        .tool-card h2 {
            color: var(--glow-blue);
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 1px solid rgba(0, 179, 255, 0.3);
            padding-bottom: 10px;
        }

        .tool-card p {
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: var(--glow-purple);
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 65, 0.3);
            color: var(--text-color);
            border-radius: 3px;
        }

        button {
            background-color: transparent;
            color: var(--glow-green);
            border: 1px solid var(--glow-green);
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            margin-top: 10px;
        }

        button:hover {
            background-color: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.2), transparent);
            transition: all 0.5s ease;
        }

        button:hover:not(:disabled)::before {
            left: 100%;
        }

        .terminal {
            background-color: #000000;
            /* negro sólido */
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 5px;
            padding: 20px;
            height: 400px;
            overflow-y: auto;
            margin-top: 10px;
            /* si separas header */
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.3);
            padding-bottom: 10px;
        }

        .terminal-content {
            line-height: 1.8;
            white-space: pre-wrap;
        }

        .prompt {
            color: var(--glow-green);
        }

        .command {
            color: var(--glow-blue);
        }

        .output {
            color: var(--text-color);
        }

        .error {
            color: var(--error-red);
        }

        .scanning-animation {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--glow-green);
            box-shadow: 0 0 10px var(--glow-green);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.2;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.2;
            }
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
            pointer-events: none;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px 0;
            border-top: 1px solid rgba(0, 255, 65, 0.3);
            font-size: 0.8rem;
            color: rgba(204, 204, 204, 0.7);
        }

        .warning {
            color: var(--error-red);
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border: 1px solid var(--error-red);
            border-radius: 5px;
        }

        .custom-command {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            border: 1px solid rgba(189, 0, 255, 0.3);
        }
    </style>
</head>

<body>
    <canvas class="matrix-bg" id="matrix"></canvas>

    <div class="container">
        <header>
            <h1>CYBERHACK TERMINAL v5.0</h1>
        </header>

        <div class="warning">
            ADVERTENCIA: Esta aplicación ejecuta comandos reales en tu sistema. Usa solo en entornos controlados y con
            los permisos adecuados.
        </div>

        <div class="grid">
            <!-- Nmap -->
            <div class="tool-card">
                <h2>NMAP SCANNER</h2>
                <p>Escaneo TCP común con versión y UDP</p>
                <div class="form-group">
                    <label for="nmap-target">Objetivo:</label>
                    <input type="text" id="nmap-target" placeholder="ej. 192.168.1.1 o dominio.com">
                </div>
                <div class="form-group">
                    <label for="nmap-options">Opciones:</label>
                    <select id="nmap-options">
                        <option value="-sV -p 22,80,443,3306">TCP común + versión</option>
                        <option value="-sU -p 53,161,123">UDP común</option>
                    </select>
                </div>
                <button onclick="runNmap()">EJECUTAR ESCANEO</button>
            </div>

            <!-- Gobuster -->
            <div class="tool-card">
                <h2>GOBUSTER</h2>
                <p>Enumeración automática de directorios o subdominios</p>
                <div class="form-group">
                    <label for="gobuster-target">URL objetivo:</label>
                    <input type="text" id="gobuster-target" placeholder="ej. http://sitio.com">
                </div>
                <div class="form-group">
                    <label for="gobuster-type">Tipo de enumeración:</label>
                    <select id="gobuster-type">
                        <option value="dir">Directorios</option>
                        <option value="sub">Subdominios</option>
                    </select>
                </div>
                <button onclick="runGobuster()">Ejecutar Gobuster</button>
            </div>

            <!-- Hydra -->
            <div class="tool-card">
                <h2>HYDRA</h2>
                <p>Fuerza bruta SSH automática (users.txt & passwords.txt)</p>
                <div class="form-group">
                    <label for="hydra-host">Host:</label>
                    <input type="text" id="hydra-host" placeholder="ej. 192.168.1.100">
                </div>
                <div class="form-group">
                    <label for="hydra-port">Puerto:</label>
                    <input type="text" id="hydra-port" placeholder="ej. 22">
                </div>
                <button onclick="runHydra()">Ejecutar Hydra</button>
            </div>



            <!-- Tarjeta de Nuclei -->
            <div class="tool-card">
                <h2>NUCLEI</h2>
                <p>Escaneo de vulnerabilidades basado en plantillas</p>
                <div class="form-group">
                    <label for="nuclei-target">Objetivo:</label>
                    <input type="text" id="nuclei-target" placeholder="ej. http://sitio.com">
                </div>
                <div class="form-group">
                    <label for="nuclei-templates">Plantillas:</label>
                    <select id="nuclei-templates">
                        <option value="-t vulnerabilities/">Vulnerabilidades</option>
                        <option value="-t exposures/">Exposiciones</option>
                        <option value="-t misconfiguration/">Misconfiguraciones</option>
                        <option value="-t cves/">CVEs específicos</option>
                    </select>
                </div>
                <button onclick="runNuclei()">EJECUTAR NUCLEI</button>
            </div>

            <!-- Tarjeta de FFUF -->
            <div class="tool-card">
                <h2>FFUF</h2>
                <p>Fuzzing web: fuerza bruta login o enumerar usuarios</p>
                <div class="form-group">
                    <label for="ffuf-mode">Modo:</label>
                    <select id="ffuf-mode">
                        <option value="login">Fuerza bruta login</option>
                        <option value="enum">Enumerar usuarios</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="ffuf-target">URL objetivo:</label>
                    <input type="text" id="ffuf-target"
                        placeholder="ej. http://sitio.com/FUZZ o https://internal.cordobitec.com.ar/employee/:id">
                </div>
                <div class="form-group">
                    <label for="ffuf-wordlist">Wordlist:</label>
                    <input type="text" id="ffuf-wordlist" placeholder="ruta a wordlist">
                </div>
                <button onclick="runFfuf()">Ejecutar FFUF</button>
            </div>

        </div>
        <!-- Comento la consola personalizada por las dudas que se manden una cagada...
        <div class="custom-command">
            <h2>CONSOLA PERSONALIZADA</h2>
            <div class="form-group">
                <label for="custom-command">Comando personalizado:</label>
                <input type="text" id="custom-command" placeholder="Escribe cualquier comando para ejecutar">
            </div>
            <button id="custom-button" onclick="runCustomCommand()">EJECUTAR COMANDO PERSONALIZADO</button>
        </div>
    -->
        <div class="terminal-header">
            <span>CONSOLE OUTPUT</span>
            <span id="status">Listo</span>
        </div>

        <div class="terminal">
            <!-- Línea de comando actual -->
            <div class="prompt-line">
                <span class="prompt">&gt; root@hackertech:~$ </span>
                <span class="command" id="current-command"></span>
            </div>

            <!-- Salida histórica de la terminal -->
            <div class="terminal-content" id="terminal-content">
                <!-- Aquí se irán agregando los outputs de los comandos -->
            </div>
        </div>



        <footer>
            <p>ADVERTENCIA: Esta aplicación ejecuta comandos REALES en tu sistema. Usa solo en entornos controlados y
                con los permisos adecuados.</p>
            <p>© 2023 CyberHack Terminal - Todos los derechos reservados</p>
        </footer>
    </div>

    <script>
        /* ----------------- Efecto Matrix ----------------- */
        function initMatrix() {
            const canvas = document.getElementById('matrix');
            if (!canvas) return console.error("Canvas no encontrado");
            const ctx = canvas.getContext('2d');
            if (!ctx) return console.error("Contexto 2D no disponible");

            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$#@%&!?*';
            const fontSize = 12;
            let columns = Math.floor(window.innerWidth / fontSize);
            let drops = Array(columns).fill(1);

            function resizeMatrix() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const newColumns = Math.floor(canvas.width / fontSize);
                if (newColumns === columns) return;
                const newDrops = Array(newColumns).fill(1);
                for (let i = 0; i < Math.min(columns, newColumns); i++) newDrops[i] = drops[i];
                columns = newColumns;
                drops = newDrops;
            }

            resizeMatrix();

            function drawMatrix() {
                ctx.fillStyle = 'rgba(10, 10, 10, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff41';
                ctx.font = `${fontSize}px monospace`;

                for (let i = 0; i < drops.length; i++) {
                    const text = letters[Math.floor(Math.random() * letters.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
                    drops[i]++;
                }
            }

            const matrixInterval = setInterval(drawMatrix, 33);
            window.addEventListener('resize', resizeMatrix);
            window.matrixInterval = matrixInterval;
        }
        document.addEventListener('DOMContentLoaded', initMatrix);

        /* ----------------- Terminal WebSocket ----------------- */
        const socket = new WebSocket('ws://localhost:3000');

        let wsReady = false;
        const wsRequests = {};
        let requestCounter = 0;

        socket.onopen = () => { wsReady = true; console.log('Conectado al servidor WS'); };
        socket.onclose = () => { wsReady = false; console.log('WS cerrado'); };
        socket.onerror = (e) => console.error('WS error', e);

        // Mensajes entrantes
        socket.onmessage = (event) => {
            let message;
            try { message = JSON.parse(event.data); } catch (e) { console.error('JSON inválido', event.data); return; }

            // Si viene reply a una request
            if (message.reply_id && wsRequests[message.reply_id]) {
                wsRequests[message.reply_id].resolve(message);
                delete wsRequests[message.reply_id];
                return;
            }

            // Manejo de salida en "stream" o mensajes sueltos
            const statusEl = document.getElementById('status');
            if (message.type === 'stdout' || message.type === 'stderr') {
                appendOutput(message.data, message.type === 'stdout' ? 'output' : 'error');
            } else if (message.type === 'close') {
                statusEl.textContent = `Comando finalizado (exit code: ${message.code})`;
                addPrompt();
            } else if (message.type === 'reply' && message.data) {
                appendOutput(message.data, 'output');
                if (message.code !== undefined) statusEl.textContent = `Comando finalizado (exit code: ${message.code})`;
                addPrompt();
            } else if (message.info) {
                appendOutput(message.info, 'output');
            } else {
                // log por si viene otro campo útil
                console.debug('WS mensaje no reconocido', message);
            }
        };

        /* ----------------- Funciones de cola/timeout para WS ----------------- */
        function sendCommandOverSocket(command, timeout = 120000) {
            return new Promise((resolve, reject) => {
                if (!wsReady) return reject(new Error('WebSocket no conectado'));
                const id = ++requestCounter;
                wsRequests[id] = { resolve, reject };
                try {
                    socket.send(JSON.stringify({ command, id }));
                } catch (err) {
                    delete wsRequests[id];
                    return reject(err);
                }
                setTimeout(() => {
                    if (wsRequests[id]) {
                        wsRequests[id].reject(new Error('Timeout de respuesta'));
                        delete wsRequests[id];
                    }
                }, timeout);
            });
        }

        /* ----------------- Funciones de Terminal ----------------- */
        function appendOutput(text, type = 'output') {
            const terminal = document.getElementById('terminal-content');
            if (!terminal) return;
            const div = document.createElement('div');
            div.className = type;
            div.textContent = text;
            terminal.appendChild(div);
            scrollToBottom();
        }

        function addPrompt() {
            const terminal = document.getElementById('terminal-content');
            if (!terminal) return;
            const promptLine = document.createElement('div');
            promptLine.className = 'prompt-line';

            const promptSpan = document.createElement('span');
            promptSpan.className = 'prompt';
            promptSpan.textContent = '> root@hackertech:~$';

            const commandSpan = document.createElement('span');
            commandSpan.className = 'command';
            commandSpan.id = 'current-command';
            commandSpan.textContent = '';

            promptLine.appendChild(promptSpan);
            promptLine.appendChild(commandSpan);
            terminal.appendChild(promptLine);
            scrollToBottom();
        }

        function scrollToBottom() {
            const content = document.getElementById('terminal-content');
            if (!content) return;
            content.scrollTop = content.scrollHeight;
        }

        function typeCommand(command, callback) {
            const terminal = document.getElementById('terminal-content');
            if (!terminal) return;
            const promptLine = document.createElement('div');
            promptLine.className = 'prompt-line';

            const promptSpan = document.createElement('span');
            promptSpan.className = 'prompt';
            promptSpan.textContent = '> root@hackertech:~$ ';

            const commandSpan = document.createElement('span');
            commandSpan.className = 'command';
            promptLine.appendChild(promptSpan);
            promptLine.appendChild(commandSpan);
            terminal.appendChild(promptLine);
            scrollToBottom();

            if (!command || command.length === 0) {
                if (callback) callback();
                return;
            }

            let i = 0;
            const interval = setInterval(() => {
                if (i < command.length) {
                    commandSpan.textContent += command[i];
                    i++;
                    scrollToBottom();
                } else {
                    clearInterval(interval);
                    if (callback) callback();
                }
            }, 30);
        }

        async function runCommand(command, label) {
            const terminal = document.getElementById('terminal-content');
            if (!terminal) return;
            terminal.textContent = ''; // limpiar consola (opcional)
            document.getElementById('status').textContent = `Ejecutando ${label}...`;

            typeCommand(command, async () => {
                try {
                    // Esperamos respuesta final del servidor via reply_id o streams (stdout/close)
                    const reply = await sendCommandOverSocket(command);
                    // Si el servidor responde con reply.message o data lo mostramos
                    if (reply && reply.data) appendOutput(reply.data, 'output');
                    if (reply && reply.code !== undefined) document.getElementById('status').textContent = `Comando finalizado (exit code: ${reply.code})`;
                    addPrompt();
                } catch (err) {
                    appendOutput(`Error al enviar comando: ${err.message}`, 'error');
                    addPrompt();
                }
            });
        }

        /* ----------------- Funciones de Herramientas ----------------- */
        function runNmap() {
            const target = document.getElementById('nmap-target')?.value || '127.0.0.1';
            const options = document.getElementById('nmap-options')?.value || '';
            runCommand(`nmap ${options} ${target}`, 'Nmap');
        }

        function runGobuster() {
            const target = document.getElementById('gobuster-target')?.value || 'http://localhost';
            const type = document.getElementById('gobuster-type')?.value;
            let cmd = '';
            if (type === 'dir') {
                cmd = `gobuster dir -u ${target} -w ./wordlists/gobuster/common.txt`;
            } else if (type === 'sub') {
                const domain = target.replace(/^https?:\/\//, '');
                cmd = `gobuster dns -d ${domain} -w ./wordlists/gobuster/subdomains.txt`;
            }
            runCommand(cmd, 'Gobuster');
        }

        function runHydra() {
            const host = document.getElementById('hydra-host')?.value || '127.0.0.1';
            const port = document.getElementById('hydra-port')?.value || '22';
            const cmd = `hydra -L ./wordlists/ssh/users.txt -P ./wordlists/ssh/passwords.txt -s ${port} -t 1 ssh://${host}`;
            runCommand(cmd, 'Hydra SSH');
        }

        function runNuclei() {
            const target = document.getElementById('nuclei-target')?.value || 'http://localhost';
            const templates = document.getElementById('nuclei-templates')?.value || '';
            runCommand(`nuclei ${templates} -u ${target}`, 'Nuclei');
        }

        function runFfuf() {
            const mode = document.getElementById('ffuf-mode')?.value;
            const target = document.getElementById('ffuf-target')?.value || 'http://localhost/FUZZ';
            const wordlist = document.getElementById('ffuf-wordlist')?.value || '/usr/share/wordlists/common.txt';
            const cmd = mode === 'login'
                ? `ffuf -u ${target} -w ${wordlist} -X POST -d '{"user":"FUFF","password":"FUFF"}' -H "Content-Type: application/json"`
                : `ffuf -u ${target} -w ${wordlist}`;
            runCommand(cmd, 'FFUF');
        }

        /* ----------------- Comandos Personalizados ----------------- */
        async function runCustomCommand() {
            const command = document.getElementById('custom-command')?.value;
            if (!command) { appendOutput('Error: Debes escribir un comando', 'error'); return; }

            const button = document.getElementById('custom-button');
            if (button) { button.disabled = true; button.textContent = 'EJECUTANDO...'; }
            appendOutput(`root@hackertech:~$ ${command}`, 'command');
            document.getElementById('status').textContent = 'Ejecutando comando personalizado...';

            try {
                const reply = await sendCommandOverSocket(command);
                if (reply && reply.data) appendOutput(reply.data, 'output');
                if (reply && reply.code !== undefined) document.getElementById('status').textContent = `Comando finalizado (exit code: ${reply.code})`;
            } catch (err) {
                appendOutput(`Error: ${err.message}`, 'error');
            } finally {
                if (button) { button.disabled = false; button.textContent = 'EJECUTAR COMANDO PERSONALIZADO'; }
                addPrompt();
            }
        }

        /* ----------------- Enter para inputs ----------------- */
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('input').forEach(input => {
                input.addEventListener('keypress', e => {
                    if (e.key === 'Enter') {
                        const toolCard = input.closest('.tool-card');
                        if (!toolCard && input.id === 'custom-command') return runCustomCommand();

                        const tool = toolCard?.querySelector('h2')?.textContent?.toLowerCase() || '';
                        if (tool.includes('nmap')) runNmap();
                        else if (tool.includes('gobuster')) runGobuster();
                        else if (tool.includes('ssh')) runHydra();
                        else if (tool.includes('nuclei')) runNuclei();
                        else if (tool.includes('ffuf')) runFfuf();
                    }
                });
            });
        });
    </script>


</body>

</html>